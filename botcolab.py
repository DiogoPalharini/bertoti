# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ste4ItvXcNj8tx3l4_jGnKSNpZQOYsl0
"""

# Atualizar pacotes do sistema (apenas se necessário)
!apt-get update -y && apt-get upgrade -y

# Instalar dependências Python estritamente necessárias
!pip install --upgrade --quiet python-telegram-bot spacy==3.7.0 numpy==1.26.0 dateparser

# Baixar o modelo de linguagem para o spaCy
!python -m spacy download pt_core_news_lg --quiet

# Confirmar instalação
!pip list | grep -E "telegram|spacy|numpy|dateparser"

#8140911817:AAFyOQ41cN7EJFP6E4Yb9l9gEjM6OIvURJQ

import dateparser
import logging
import nest_asyncio
import asyncio
from datetime import datetime
from telegram import Update
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    filters, ContextTypes, ConversationHandler
)
import random
import re

# Permitir loops assíncronos no ambiente
nest_asyncio.apply()

# Configuração de logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# Substitua pelo token do seu bot
TELEGRAM_TOKEN = '8140911817:AAFyOQ41cN7EJFP6E4Yb9l9gEjM6OIvURJQ'

# Estados da conversa
ESPERANDO_ENTRADA = range(1)

# Dicionário de cidades conhecidas
CIDADES = {
    "cuiabá", "são paulo", "rio de janeiro", "curitiba", "belém", "porto alegre",
    "recife", "fortaleza", "manaus", "salvador", "goiânia", "brasília", "florianópolis"
}

# Função para simular resultados de voos
def buscar_voos_simulados(origem, destino, data_ida):
    return [
        {
            "Origem": origem,
            "Destino": destino,
            "Duração": f"{random.randint(1, 5)}h {random.randint(0, 59)}min",
            "Preço": f"R$ {random.randint(200, 1500)},00"
        }
        for _ in range(3)
    ]

# Função para extrair cidade
def extrair_cidade(mensagem):
    cidades_encontradas = [cidade for cidade in CIDADES if cidade in mensagem.lower()]
    return [cidade.capitalize() for cidade in cidades_encontradas]

# Função para extrair data
def extrair_data(mensagem):
    # Regex para encontrar padrões de data (ex.: 25/12, 25-12, 25 de dezembro)
    match = re.search(r"(\d{1,2}[/-]\d{1,2})|(\d{1,2}\s+de\s+\w+)", mensagem.lower())
    if match:
        data_str = match.group(0)
        data = dateparser.parse(data_str, languages=['pt'], settings={'PREFER_DATES_FROM': 'future'})
        return data
    return None

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Olá! Envie uma mensagem com destino, data e origem de qualquer forma, por exemplo:\n"
        "- 'Quero ir para Salvador dia 25 saindo de Cuiabá'\n"
        "- 'Vou para Recife no dia 25/12 partindo de São Paulo'"
    )
    return ESPERANDO_ENTRADA

async def processar_entrada(update: Update, context: ContextTypes.DEFAULT_TYPE):
    mensagem = update.message.text.lower()

    # Extrair cidades
    cidades_encontradas = extrair_cidade(mensagem)
    if len(cidades_encontradas) < 2:
        await update.message.reply_text(
            "Não consegui identificar origem e destino corretamente. Certifique-se de mencionar duas cidades conhecidas."
        )
        return ESPERANDO_ENTRADA

    origem, destino = cidades_encontradas[:2]

    # Extrair data
    data = extrair_data(mensagem)
    if not data:
        await update.message.reply_text("Não consegui entender a data. Tente enviar algo como 'dia 25/12' ou '25 de dezembro'.")
        return ESPERANDO_ENTRADA

    # Validar data
    if data.date() < datetime.today().date():
        await update.message.reply_text("A data precisa ser de hoje ou no futuro. Por favor, tente novamente.")
        return ESPERANDO_ENTRADA

    # Responder com os resultados
    data_str = data.strftime('%d/%m/%Y')

    voos = buscar_voos_simulados(origem, destino, data_str)
    resultados = "\n".join(
        [f"Origem: {v['Origem']}, Destino: {v['Destino']}, Duração: {v['Duração']}, Preço: {v['Preço']}" for v in voos]
    )
    await update.message.reply_text(
        f"Procurando voos de {origem} para {destino} no dia {data_str}...\n\nResultados encontrados:\n{resultados}"
    )
    return ConversationHandler.END

async def cancelar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Conversa cancelada. Se precisar, é só chamar!")
    return ConversationHandler.END

async def main():
    application = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    conversa = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            ESPERANDO_ENTRADA: [MessageHandler(filters.TEXT & ~filters.COMMAND, processar_entrada)],
        },
        fallbacks=[CommandHandler('cancel', cancelar)],
    )

    application.add_handler(conversa)
    await application.run_polling()

if __name__ == '__main__':
    asyncio.run(main())

